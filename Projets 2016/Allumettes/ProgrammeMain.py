from tkinter import *from tkinter.messagebox import *import csvclass SampleApp(Tk):    ''' Inch'Allah tu vas t'amuser '''    def __init__(self, *args, **kwargs):        ''' Initialisation du programme '''        Tk.__init__(self, *args, **kwargs)        self.title("Casse-Tête Allumettes")        global name        name = ""        global timer        timer = [0, 0, 0]        global timerstate        timerstate = True        # Création du canvas        self.canvas = Canvas(width=780, height=350, background="#66A7CC")        self.canvas.pack(fill="both", expand=True)        self.naming()    def naming(self):        '''Affiche la fenêtre de démarrage '''        self.canvas.create_text(390, 100, text="Entrez votre nom :", fill="White", font=("cambria", 24, 'bold'))        self.nom = StringVar()        self.ligne_saisie = Entry(self.canvas, textvariable=self.nom, justify=CENTER, font=("cambria", 14, 'bold'), relief=FLAT)        self.ligne_saisie.place(x=390, y=150, anchor=CENTER)        self.validNom = Button(self.canvas, text="OK", bg="yellow", fg="#66A7CC", relief=FLAT, font=("cambria", 14, 'bold'), command=self.validerNom)        self.validNom.place(x=390, y=200, anchor=CENTER)    def validerNom(self):        ''' Validation du nom entré par l'utilisateur '''        global name        name = self.nom.get()        name = name.strip()        if len(name) == 0:            showwarning("Erreur", "Vous devez entrez un nom !")        else:            self.validNom.destroy()            self.ligne_saisie.destroy()            self.canvas.delete("all")            self.menuing()    def menuing(self):        ''' Affichage du menu d'accueil '''        self.canvas.create_text(390, 30, text="Casse-Tête Allumettes", fill="White", font=("cambria", 24, 'bold'))        self.canvas.create_text(780, 350, anchor=SE, text="Par Pierre et Sam :)", fill="White", font=("cambria", 12, 'bold'))        self.level1 = Button(self.canvas, text="Niveau 1", bg="yellow", fg="#66A7CC", relief=FLAT,font=("cambria", 14, 'bold'), command=(lambda: self.passageLevel(level=1)))        self.level1.place(x="290", y="125", anchor=CENTER)        self.level2 = Button(self.canvas, text="Niveau 2", bg="yellow", fg="#66A7CC", relief=FLAT,font=("cambria", 14, 'bold'), command=lambda: self.passageLevel(level=2))        self.level2.place(x="490", y="125", anchor=CENTER)        self.level3 = Button(self.canvas, text="Niveau 3", bg="yellow", fg="#66A7CC", relief=FLAT, font=("cambria", 14, 'bold'), command=lambda: self.passageLevel(level=3))        self.level3.place(x="290", y="200", anchor=CENTER)        self.level4 = Button(self.canvas, text="Niveau 4", bg="yellow", fg="#66A7CC", relief=FLAT, font=("cambria", 14, 'bold'), command=lambda: self.passageLevel(level=4))        self.level4.place(x="490", y="200", anchor=CENTER)        self.classement = Button(self.canvas, text="Leaderboard", bg="White", fg="#66A7CC", relief=FLAT, font=("cambria", 14, 'bold'), command=lambda: self.passageClassement())        self.classement.place(x="10", y="340", anchor=SW)    def retourMenu(self):        '''Passage au menu d'accueil '''        global timerstate        timerstate = True        self.bouton.destroy()        self.tonbou.destroy()        self.appui.destroy()        self.recommencer.destroy()        self.timeText.destroy()        self.canvas.delete("all")        self.menuing()        self.reset()    def leveling(self, level):        ''' Affichage de la fenêtre de jeu        :param level: niveau choisi par l'utilisateur '''        self.bouton = Button(text="Confirmer", bg="yellow", fg="#66A7CC", relief=FLAT, font=("cambria", 10, 'bold'), command=lambda: self.confirmation(level))        self.bouton.place(x="775", y="345", anchor=SE)        self.tonbou = Button(text="?", bg="yellow", fg="#66A7CC", relief=FLAT, font=("cambria", 10, 'bold'), command=self.instruction)        self.tonbou.place(x='775', y='5', anchor=NE)        self.appui = Button(text="<--", bg="yellow", fg="#66A7CC", relief=FLAT, font=("cambria", 10, 'bold'), command=self.retourMenu)        self.appui.place(x="5", y="5")        self.recommencer = Button(text="Restart", bg="yellow", fg="#66A7CC", relief=FLAT, font=("cambria", 10, 'bold'), command=self.restartLevel)        self.recommencer.place(x="50", y="5")        # Data pour track/suivre l'item qu'on bouge        self._drag_data = {"x": 0, "y": 0, "item": None}        # Pour l'item qu'on rotate        self.element = {"item": None}        # Pour la confirmation        self.confirm = {"item": None}        # Constantes pour les dimensions        self.largeur = 10        self.longueur = 80        # Création des allumettes        # self._create_token((x, y), "color", "h/v", "yes/no")        csv_in = open(str(level) + 'tableau.csv', 'r')  # Charge les coordonnées des allumettes du niveau        myreader = csv.reader(csv_in, delimiter=',')        tab = list(myreader)        csv_in.close()        # Création des allumettes selon le .csv ouvert ci-dessus        for x in tab:            self._create_token((int(x[0]), int(x[1])), x[2], x[3], x[4])        csv_in = open(str(level) + "consigne.csv", 'r')  # Charge la consigne du niveau        monreader = csv.reader(csv_in, delimiter=',')        tab2 = list(monreader)            csv_in.close()        # Affichage de la consigne        self.canvas.create_text(390, 330, text=tab2[0][0], fill="White", font=("cambria", 15, 'bold'))        self.canvas.create_text(390, 30, text=tab2[0][0], fill="White", font=("cambria", 18, 'bold'))        # Bind pour click, drag et release l'allumette        self.canvas.tag_bind("firev", "<ButtonPress-1>", self.OnTokenButtonPress)        self.canvas.tag_bind("firev", "<ButtonRelease-1>", self.OnTokenButtonRelease)        self.canvas.tag_bind("firev", "<B1-Motion>", self.OnTokenMotion)        self.canvas.tag_bind("fireh", "<ButtonPress-1>", self.OnTokenButtonPress)        self.canvas.tag_bind("fireh", "<ButtonRelease-1>", self.OnTokenButtonRelease)        self.canvas.tag_bind("fireh", "<B1-Motion>", self.OnTokenMotion)        # Bind pour rotate        self.canvas.tag_bind("fireh", "<ButtonPress-2>", self.rotateh)        self.canvas.tag_bind("firev", "<ButtonPress-2>", self.rotatev)        # Affichage du timer        self.timeText = Label(text="00:00:00", font=("Helvetica", 15))        self.timeText.place(x='695', y='345', anchor=SE)        self.update_timeText()    def restartLevel(self):        ''' Redémarre le niveau / Reset du timer '''        global timerstate        timerstate = True        self.reset()    def passageLevel(self, level):        ''' Transition vers le niveau choisi par l'utilisateur '''        self.level1.destroy()        self.level2.destroy()        self.level3.destroy()        self.level4.destroy()        self.classement.destroy()        self.canvas.delete("all")        self.leveling(level)    def passageClassement(self):        ''' Transition vers le menu du leaderboard'''        self.level1.destroy()        self.level2.destroy()        self.level3.destroy()        self.level4.destroy()        self.classement.destroy()        self.canvas.delete("all")        self.pageClassement()    def pageClassement(self):        ''' Affichage du menu du leaderboard '''        self.canvas.create_text(390, 30, text="Leaderboard", fill="White", font=("cambria", 24, 'bold'))        self.retour = Button(text="<--", bg="yellow", fg="#66A7CC", relief=FLAT, font=("cambria", 10, 'bold'), command=self.retourMenuClassement)        self.retour.place(x="5", y="5")        self.level1 = Button(self.canvas, text="Niveau 1", bg="yellow", fg="#66A7CC", relief=FLAT, font=("cambria", 14, 'bold'), command=lambda: self.leaderboard(level=1))        self.level1.place(x="290", y="125", anchor=CENTER)        self.level2 = Button(self.canvas, text="Niveau 2", bg="yellow", fg="#66A7CC", relief=FLAT, font=("cambria", 14, 'bold'), command=lambda: self.leaderboard(level=2))        self.level2.place(x="490", y="125", anchor=CENTER)        self.level3 = Button(self.canvas, text="Niveau 3", bg="yellow", fg="#66A7CC", relief=FLAT, font=("cambria", 14, 'bold'), command=lambda: self.leaderboard(level=3))        self.level3.place(x="290", y="200", anchor=CENTER)        self.level4 = Button(self.canvas, text="Niveau 4", bg="yellow", fg="#66A7CC", relief=FLAT, font=("cambria", 14, 'bold'), command=lambda: self.leaderboard(level=4))        self.level4.place(x="490", y="200", anchor=CENTER)        self.clearlead = Button(self.canvas, text="Effacer les classements", bg="yellow", fg="#66A7CC", relief=FLAT, font=("cambria", 14, 'bold'), command=lambda: self.effacerLeClassement())        self.clearlead.place(x="390", y="275", anchor=CENTER)    def leaderboard(self, level):        ''' Affichage du leaderboard du niveau choisi par l'utilisateur '''        top = Toplevel(self)        top.title("Leaderboard")        score = []        # Ouverture du .csv contenant les scores        csv_in = open('donnees.csv', 'r')        myreader = csv.reader(csv_in, delimiter=',')        tab = list(myreader)        csv_in.close()        # On ne sélectionne que ceux qui nous intéressent (niveau choisi)        for x in tab:            if x[1] == str(level):                score.append(x)            else:                pass        score.sort(key=lambda x: x[2]) # Tri des scores choisis selon le temps        # Création du tableau qui va contenir les scores        vsb = Scrollbar(top, orient=VERTICAL, )        vsb.grid(row=0, column=1, sticky=N + S)        c = Canvas(top, yscrollcommand=vsb.set, background="#66A7CC")        c.grid(row=0, column=0, sticky="news")        Label(c, text="Nom", font=("cambria", 16, 'bold'), relief=FLAT, width=15, bg='yellow', fg="#66A7CC").grid(row=0, column=0)        Label(c, text="Temps", font=("cambria", 16, 'bold'), relief=FLAT, width=15, bg='yellow', fg="#66A7CC").grid(row=0, column=1)        # Affiche des scores dans un tableau        r = 1        for a in score:            if r % 2 == 0:                Label(c, text=a[0], relief=FLAT, font=("cambria", 15), width=15, bg='yellow', fg="#66A7CC").grid(row=r,column=0)            else:                Label(c, text=a[0], relief=FLAT, font=("cambria", 15), width=15, bg='lightyellow', fg="#66A7CC").grid(row=r, column=0)            r += 1        r = 1        for b in score:            if r % 2 == 0:                Label(c, text=b[2], relief=FLAT, font=("cambria", 15), width=15, bg='yellow', fg="#66A7CC").grid(row=r, column=1)            else:                Label(c, text=b[2], relief=FLAT, font=("cambria", 15), width=15, bg='lightyellow', fg="#66A7CC").grid(                    row=r, column=1)            r += 1    def retourMenuClassement(self):        ''' Passage au menu du leaderboard '''        self.retour.destroy()        self.level1.destroy()        self.level2.destroy()        self.level3.destroy()        self.level4.destroy()        self.clearlead.destroy()        self.canvas.delete("all")        self.menuing()    def effacerLeClassement(self):        ''' Efface les données du .csv (classement) '''        fichierrr = open("donnees.csv", "w")        fichierrr.truncate()        fichierrr.close()        showinfo("Info", "Les classements des niveaux ont été remis à zéro !")    def _create_token(self, coord, color, orientation, move):        ''' Créé un bâton/allumette avec des coordonnées, une couleur, une orientation et si il est bougeable '''        (x, y) = coord        if orientation == "v":            if move == "yes":                self.canvas.create_rectangle(x, y, x + self.largeur, y + self.longueur, outline=color, fill=color, tags="firev")            elif move == "no":                self.canvas.create_rectangle(x, y, x + self.largeur, y + self.longueur, outline=color, fill=color, tags="notFire")        elif orientation == "h":            if move == "yes":                self.canvas.create_rectangle(x, y, x + self.longueur, y + self.largeur, outline=color, fill=color, tags="fireh")            elif move == "no":                self.canvas.create_rectangle(x, y, x + self.longueur, y + self.largeur, outline=color, fill=color, tags="notFire")    def OnTokenButtonPress(self, event):        ''' Récupère les coordonnées x et y de l'allumette au moment du clic '''        self._drag_data["item"] = self.canvas.find_closest(event.x, event.y)        self._drag_data["x"] = event.x        self._drag_data["y"] = event.y    def OnTokenButtonRelease(self, event):        ''' Récupère les coordonnées x et y de l'allumette au moment de la relache du clic '''        self._drag_data["item"] = None        self._drag_data["x"] = 0        self._drag_data["y"] = 0    def OnTokenMotion(self, event):        ''' Déplace l'allumette en mettant à jour ses coordonnées (boucle constante pendant le déplacement) '''        # calcule de combien a bougé l'allumette        delta_x = event.x - self._drag_data["x"]  # Nouvelle position x - position x de départ        delta_y = event.y - self._drag_data["y"]        # déplace l'allumette        self.canvas.move(self._drag_data["item"], delta_x, delta_y)        # Enregistre la nouvelle position        self._drag_data["x"] = event.x        self._drag_data["y"] = event.y    def rotateh(self, event):        ''' Tourne une allumette de 90°: une horizontale vers une verticale '''        self.element["item"] = self.canvas.find_closest(event.x, event.y, )        self.canvas.delete(self, self.element["item"])        self._create_token((event.x - 5, event.y - 40), "yellow", "v", "yes")    def rotatev(self, event):        ''' Tourne une allumette de 90°: une verticale vers une horizontale '''        self.element["item"] = self.canvas.find_closest(event.x, event.y, )        self.canvas.delete(self, self.element["item"])        self._create_token((event.x - 40, event.y - 5), "yellow", "h", "yes")    def confirmation(self, level):        ''' Informe l'utilisateur de la réussite ou de l'échec du niveau '''        global timerstate        csv_in = open(str(level) + "confirmation.csv", 'r') # Charge le .csv des coordonnées solutions        myreader = csv.reader(csv_in, delimiter=',')        tab = list(myreader)        csv_in.close()        # Verification de chaque coordonnée (voir si il y a bien une allumette)        for x in tab:            self.confirm["item"] = self.canvas.find_overlapping(int(x[0]), int(x[1]), int(x[0]), int(x[1]))            if len(self.confirm["item"]) == 2:                pass            else:                showwarning("C'est pas réussi !", "Vous devez réessayer !")                return None        timerstate = False        showinfo("Bravo !", "Vous avez réussi !")        self.score(level)    def score(self, level):        ''' Ajoute le nom, niveau et temps final dans le fichier .csv pour pouvoir l'afficher dans le leaderboard '''        global name        global timer        newtimer = ["%02d" % n for n in timer]        finaltimer = newtimer[0] + ":" + newtimer[1] + ":" + newtimer[2]        fichier = open("donnees.csv", "a", newline='')        écrivain = csv.writer(fichier)        écrivain.writerow((name, level, finaltimer))        fichier.close()    def instruction(self):        ''' Affiche une aide d'utilisation '''        showinfo("Tourner une allumette", "Cliquez sur la molette pour tourner l'allumette à 90º")    def update_timeText(self):        ''' Fonction chronomètre '''        if (timerstate):            global timer            pattern = '{0:02d}:{1:02d}:{2:02d}'            timer[2] += 1            if (timer[2] >= 100):                timer[2] = 0                timer[1] += 1            if (timer[1] >= 60):                timer[0] += 1                timer[1] = 0            timeString = pattern.format(timer[0], timer[1], timer[2])            self.timeText.configure(text=timeString)        self.after(10, self.update_timeText)    def reset(self):        ''' Remise à zéro du chronomètre'''        global timer        timer = [0, 0, 0]        self.timeText.configure(text='00:00:00')app = SampleApp()app.mainloop()